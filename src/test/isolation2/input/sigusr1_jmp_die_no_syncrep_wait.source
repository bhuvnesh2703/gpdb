-- Scenario:
-- We should never wait for syncrep while handling a SIGUSR1 signal. This is because waiting for syncrep may involve
-- waiting on a latch that may depend on a SIGUSR1 for unblocking. We can end up waiting for syncrep if we receive a SIGTERM
-- while we are handling a SIGUSR1 and we have a transaction on backend exit.

include: helpers/server_helpers.sql;
CREATE FUNCTION send_sigusr1(int)
   RETURNS void
   AS '@abs_builddir@/isolation2_regress@DLSUFFIX@'
   LANGUAGE C IMMUTABLE STRICT NO SQL;

CREATE EXTENSION IF NOT EXISTS gp_inject_fault;

-- reset any existing fault
SELECT gp_inject_fault2('all', 'reset', dbid, hostname, port) FROM master();

-- create a temporary table as we need RemoveTempRelationsCallback to be triggered on pg_terminate_backend
1: CREATE TEMP TABLE tmp_syncrep_sigusr1(i int);

-- add a fault at the start of SIGUSR1 handler
SELECT gp_inject_fault2('procsignal_sigusr1_handler_start', 'suspend', dbid, hostname, port) FROM master();

-- add fault at wal sender loop so that we don't ship anything to standby
SELECT gp_inject_fault2('wal_sender_loop', 'suspend', dbid, hostname, port) FROM master();

-- send SIGUSR1 to the backend which has temp tables (there is only other other backend)
SELECT send_sigusr1(pid) FROM pg_stat_activity WHERE pid != pg_backend_pid();

-- as of now there will be 2 queries
SELECT query FROM pg_stat_activity;

-- send SIGTERM to the backend to close the connection which created temp table
SELECT pg_terminate_backend(pid) FROM pg_stat_activity WHERE pid != pg_backend_pid();

-- reset the sigusr1 fault, so that code jumps to die
SELECT gp_inject_fault2('procsignal_sigusr1_handler_start', 'reset', dbid, hostname, port) FROM master();

-- now we should see only 1 query as we terminated session 1.
SELECT query FROM pg_stat_activity;

-- reset the faults
SELECT gp_inject_fault2('wal_sender_loop', 'reset', dbid, hostname, port) FROM master();
