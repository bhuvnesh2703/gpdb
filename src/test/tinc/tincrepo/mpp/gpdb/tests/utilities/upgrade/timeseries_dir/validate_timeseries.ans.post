-- weighted moving functions
drop table if exists sale; create table sale (pn int);
DROP TABLE
psql:/path/sql_file:1: NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'pn' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
CREATE TABLE
insert into sale (pn) values (100);
INSERT 0 1
insert into sale (pn) values (100);
INSERT 0 1
insert into sale (pn) values (200);
INSERT 0 1
insert into sale (pn) values (200);
INSERT 0 1
insert into sale (pn) values (300);
INSERT 0 1
insert into sale (pn) values (400);
INSERT 0 1
insert into sale (pn) values (400);
INSERT 0 1
insert into sale (pn) values (500);
INSERT 0 1
insert into sale (pn) values (500);
INSERT 0 1
insert into sale (pn) values (600);
INSERT 0 1
insert into sale (pn) values (700);
INSERT 0 1
insert into sale (pn) values (800);
INSERT 0 1
select pn,
       wm_avg(pn, array[0.1, 0.2, 0.7], 0) over(order by pn),
       wm_avg(pn::float, array[0.1, 0.2, 0.7], 0) over(order by pn)
from sale;
 pn  |        wm_avg        | wm_avg 
-----+----------------------+--------
 100 | 100.0000000000000000 |    100
 100 | 100.0000000000000000 |    100
 200 | 170.0000000000000000 |    170
 200 | 190.0000000000000000 |    190
 300 | 270.0000000000000000 |    270
 400 | 360.0000000000000000 |    360
 400 | 390.0000000000000000 |    390
 500 | 470.0000000000000000 |    470
 500 | 490.0000000000000000 |    490
 600 | 570.0000000000000000 |    570
 700 | 660.0000000000000000 |    660
 800 | 760.0000000000000000 |    760
(12 rows)

select pn,
       wm_avg(pn::float, array[0.2, 0.4], -2) over(order by pn),
       wm_avg(pn::float, array[0.2, 0.4], -1) over(order by pn),
       wm_avg(pn::float, array[0.2, 0.4], +1) over(order by pn),
       wm_avg(pn::float, array[0.2, 0.4], +2) over(order by pn)
from sale;
 pn  |      wm_avg      |      wm_avg      |      wm_avg      |      wm_avg      
-----+------------------+------------------+------------------+------------------
 100 |                  |                  |              100 | 166.666666666667
 100 |                  |              100 | 166.666666666667 |              200
 200 |              100 |              100 |              200 | 266.666666666667
 200 |              100 | 166.666666666667 | 266.666666666667 | 366.666666666667
 300 | 166.666666666667 |              200 | 366.666666666667 |              400
 400 |              200 | 266.666666666667 |              400 | 466.666666666667
 400 | 266.666666666667 | 366.666666666667 | 466.666666666667 |              500
 500 | 366.666666666667 |              400 |              500 | 566.666666666667
 500 |              400 | 466.666666666667 | 566.666666666667 | 666.666666666667
 600 | 466.666666666667 |              500 | 666.666666666667 | 766.666666666667
 700 |              500 | 566.666666666667 | 766.666666666667 |              800
 800 | 566.666666666667 | 666.666666666667 |              800 |                 
(12 rows)

select pn,
       wm_var_pop(pn, array[0.1, 0.2, 0.7], 0) over (order by pn),
       wm_var_samp(pn, array[0.1, 0.2, 0.7], 0) over(order by pn),
       wm_var_pop(pn::float, array[0.1, 0.2, 0.7], 0) over (order by pn),
       wm_var_samp(pn::float, array[0.1, 0.2, 0.7], 0) over(order by pn)
from sale;
 pn  |      wm_var_pop       |      wm_var_samp      |    wm_var_pop    |   wm_var_samp    
-----+-----------------------+-----------------------+------------------+------------------
 100 |                     0 |                       |                0 |                 
 100 |                     0 |                     0 |                0 |                0
 200 | 2100.0000000000000000 | 4565.2173913043478261 |             2100 | 4565.21739130435
 200 |  900.0000000000000000 | 1956.5217391304347826 |              900 | 1956.52173913043
 300 | 2100.0000000000000000 | 4565.2173913043478261 |             2100 | 4565.21739130435
 400 | 4400.0000000000000000 | 9565.2173913043478261 |             4400 | 9565.21739130435
 400 |  900.0000000000000000 | 1956.5217391304347826 |              900 | 1956.52173913043
 500 | 2100.0000000000000000 | 4565.2173913043478261 |             2100 | 4565.21739130435
 500 |  900.0000000000000000 | 1956.5217391304347826 |              900 | 1956.52173913043
 600 | 2100.0000000000000000 | 4565.2173913043478261 |             2100 | 4565.21739130435
 700 | 4400.0000000000000000 | 9565.2173913043478261 | 4399.99999999994 | 9565.21739130422
 800 | 4400.0000000000000000 | 9565.2173913043478261 |             4400 | 9565.21739130435
(12 rows)

select pn,
       wm_stddev_pop(pn::float, array[0.2, 0.4], -2) over(order by pn),
       wm_stddev_pop(pn::float, array[0.2, 0.4], -1) over(order by pn),
       wm_stddev_pop(pn::float, array[0.2, 0.4], +1) over(order by pn),
       wm_stddev_pop(pn::float, array[0.2, 0.4], +2) over(order by pn)
from sale;
 pn  |    wm_stddev_pop     |    wm_stddev_pop     |    wm_stddev_pop     |    wm_stddev_pop     
-----+----------------------+----------------------+----------------------+----------------------
 100 |                      |                      | 1.12391596029051e-06 |     47.1404520791032
 100 |                      |                    0 |     47.1404520791032 | 2.24783192058101e-06
 200 |                    0 | 1.12391596029051e-06 | 2.24783192058101e-06 |     47.1404520791033
 200 | 1.12391596029051e-06 |     47.1404520791032 |     47.1404520791033 |     47.1404520791034
 300 |     47.1404520791032 | 2.24783192058101e-06 |     47.1404520791034 | 4.49566384116203e-06
 400 | 2.24783192058101e-06 |     47.1404520791033 | 4.49566384116203e-06 |     47.1404520791036
 400 |     47.1404520791033 |     47.1404520791034 |     47.1404520791036 | 6.35782877604167e-06
 500 |     47.1404520791034 | 4.49566384116203e-06 | 6.35782877604167e-06 |     47.1404520791036
 500 | 4.49566384116203e-06 |     47.1404520791036 |     47.1404520791036 |      47.140452079104
 600 |     47.1404520791036 | 6.35782877604167e-06 |      47.140452079104 |      47.140452079104
 700 | 6.35782877604167e-06 |     47.1404520791036 |      47.140452079104 |                    0
 800 |     47.1404520791036 |      47.140452079104 |                    0 |                     
(12 rows)

select wm_avg(a, '{0.2}'::numeric[], 0) over (order by a)
from (values('NaN'::numeric),(0.1)) s(a);
         wm_avg         
------------------------
 0.10000000000000000000
                    NaN
(2 rows)

select wm_avg(a, '{0.2, 0.3}'::numeric[], 0) over (order by a)
from (values(NULL::numeric),(0.1)) s(a);
         wm_avg         
------------------------
 0.10000000000000000000
 0.10000000000000000000
(2 rows)

select wm_avg(pn, ary, 3) over (order by pn)
from sale, (values('{0.1, 0.2}'::float[])) s(ary);
psql:/path/sql_file:1: ERROR:  weight vector argument must be a constant (nodeWindow.c:7097)
select wm_avg(pn, '{0.1,0.2}'::float[], ofs) over (order by pn)
from sale, (values(3)) s(ofs);
psql:/path/sql_file:1: ERROR:  offset argument must be a constant (nodeWindow.c:7109)
select wm_var_pop(pn, array[0.1, 0.9], 0) over
    (order by pn rows between 1 preceding and current row) from sale;
psql:/path/sql_file:1: ERROR:  window function "wm_var_pop" cannot be used with a framed window specification
LINE 1: select wm_var_pop(pn, array[0.1, 0.9], 0) over
               ^
drop table if exists gapinput cascade; -- ignore
psql:/path/sql_file:1: NOTICE:  drop cascades to rule _RETURN on view gapinputview
psql:/path/sql_file:1: NOTICE:  drop cascades to view gapinputview
DROP TABLE
create table gapinput
(
	a int,
	b int,
	pk1 int,
	pk2 int,
	sk bigint
)
distributed randomly;
CREATE TABLE
-- NULL partitioning key
delete from gapinput; -- ignore
DELETE 0
insert into gapinput values
     (0, 0, NULL, NULL, 7);
INSERT 0 1
select pk1, pk2, qk, sk, b
from gapinput
sequence q as (
        partition by pk1, pk2
        order by sk
        key qk every 2 between 4 and 8 )
order by pk1, pk2, qk, sk, b;
 pk1 | pk2 | qk | sk | b 
-----+-----+----+----+---
     |     |  4 |    |  
     |     |  6 |  7 | 0
     |     |  8 |    |  
(3 rows)

delete from gapinput; -- ignore
DELETE 1
insert into gapinput values
     (0, 0, -1, -1, 1),
     (1, 0, -1, -1, 3),
     (2, 0, -1, -1, 5),
     (3, 0, -1, -1, 6),
     (4, 0, -1, -1, 9),
     (5, 0, -1, -1, 11),
     (6, 0, -1, -1, 13),
     (7, 0, -1, -2, 2),
     (8, 0, -1, -2, 4),
     (9, 0, -1, -3, 7),
     (10, 0, -1, -3, 10),
     (11, 0, -1, -3, 12),
     (12, 0, -1, -4, 14);
INSERT 0 13
-- Sub-query
select sum((select si from gapinput
	sequence q as (order by sk key si every 3 between 2 and 8)
	order by si limit 1));
 sum 
-----
  -1
(1 row)

-- CSQ
select a, 1 + (select qk + t.a from gapinput
	sequence q as (order by sk key qk every 3 between 2 and 8)
	order by qk limit 1)
from gapinput t order by a;
 a  | ?column? 
----+----------
  0 |        0
  1 |        1
  2 |        2
  3 |        3
  4 |        4
  5 |        5
  6 |        6
  7 |        7
  8 |        8
  9 |        9
 10 |       10
 11 |       11
 12 |       12
(13 rows)

select a, 1 + (select qk from gapinput
	where a = t.a sequence q as (order by sk key qk every 2 between 4 and 8)
	order by qk limit 1)
from gapinput t order by a;
 a  | ?column? 
----+----------
  0 |        1
  1 |        3
  2 |        5
  3 |        5
  4 |        5
  5 |        5
  6 |        5
  7 |        3
  8 |        5
  9 |        5
 10 |        5
 11 |        5
 12 |        5
(13 rows)

select a, 1 + (select qk from gapinput
	sequence q as (order by sk key qk every t.a + 1 between 4 and 8)
	order by qk limit 1)
from gapinput t order by a;
 a  | ?column? 
----+----------
  0 |        2
  1 |        1
  2 |        2
  3 |        1
  4 |        0
  5 |       -1
  6 |       -2
  7 |       -3
  8 |       -4
  9 |       -5
 10 |       -6
 11 |       -7
 12 |       -8
(13 rows)

select a, 1 + (select qk from gapinput
	sequence q as (order by sk key qk every 2 between t.a and 4)
	order by qk limit 1)
from gapinput t order by a;
 a  | ?column? 
----+----------
  0 |        1
  1 |        2
  2 |        1
  3 |        2
  4 |        1
  5 |        2
  6 |        1
  7 |        2
  8 |        1
  9 |        2
 10 |        1
 11 |        2
 12 |        1
(13 rows)

select a, 1 + (select qk from gapinput
	sequence q as (order by sk key qk every 2 between 0 and t.a)
	order by qk limit 1)
from gapinput t order by a;
 a  | ?column? 
----+----------
  0 |        1
  1 |        1
  2 |        1
  3 |        1
  4 |        1
  5 |        1
  6 |        1
  7 |        1
  8 |        1
  9 |        1
 10 |        1
 11 |        1
 12 |        1
(13 rows)

-- lead/lag/first_value/last_value
select pk1, a, b, sk, qk, lead(qk) over (q), lag(qk) over (q),
	first_value(si) over(q), last_value(qk) over (q)
from gapinput
sequence q as (partition by pk1 order by sk key qk every 3 between 2 and 6);
psql:/path/sql_file:1: ERROR:  column "si" does not exist
LINE 2:  first_value(si) over(q), last_value(qk) over (q)
                     ^
-- CTAS
create temp table tempgap as
select t1.sk, rank() over(q), qk
from gapinput t1 inner join gapinput t2 on t1.a = t2.b
sequence q as (order by t1.sk key qk every 1 between 4 and 8);
psql:/path/sql_file:1: NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column(s) named 'sk' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
SELECT 18
select * from tempgap;
 sk | rank | qk 
----+------+----
  1 |    1 |  1
  1 |    2 |  1
  1 |    3 |  1
  1 |    4 |  1
  1 |    5 |  1
  1 |    6 |  1
  1 |    7 |  1
  1 |    8 |  1
  1 |    9 |  1
  1 |   10 |  1
  1 |   11 |  1
  1 |   12 |  1
  1 |   13 |  1
    |   13 |  4
    |   13 |  5
    |   13 |  6
    |   13 |  7
    |   13 |  8
(18 rows)

drop table tempgap;
DROP TABLE
-- distinct
select distinct a, b, sk, qk from gapinput
sequence q as (order by sk key qk every 2 between 4 and 8);
 a  | b | sk | qk 
----+---+----+----
  0 | 0 |  1 |  0
  1 | 0 |  3 |  2
  2 | 0 |  5 |  4
  3 | 0 |  6 |  6
  4 | 0 |  9 |  8
  5 | 0 | 11 | 10
  6 | 0 | 13 | 12
  7 | 0 |  2 |  2
  8 | 0 |  4 |  4
  9 | 0 |  7 |  6
 10 | 0 | 10 | 10
 11 | 0 | 12 | 12
 12 | 0 | 14 | 14
(13 rows)

select distinct on (qk) a, b, qk from gapinput
sequence q as (order by sk key qk every 2 between 4 and 8);
 a  | b | qk 
----+---+----
  0 | 0 |  0
  1 | 0 |  2
  8 | 0 |  4
  9 | 0 |  6
  4 | 0 |  8
  5 | 0 | 10
  6 | 0 | 12
 12 | 0 | 14
(8 rows)

-- prepare
prepare x (int) as
select a, b, sk, qk from gapinput
sequence q as (order by sk key qk every $1 between 4 and 8);
PREPARE
execute x(2);
 a  | b | sk | qk 
----+---+----+----
  0 | 0 |  1 |  0
  7 | 0 |  2 |  2
  1 | 0 |  3 |  2
  8 | 0 |  4 |  4
  2 | 0 |  5 |  4
  3 | 0 |  6 |  6
  9 | 0 |  7 |  6
  4 | 0 |  9 |  8
 10 | 0 | 10 | 10
  5 | 0 | 11 | 10
 11 | 0 | 12 | 12
  6 | 0 | 13 | 12
 12 | 0 | 14 | 14
(13 rows)

execute x(-1);
psql:/path/sql_file:1: ERROR:  width of numeric interval not positive
deallocate x;
DEALLOCATE
prepare x (int) as
select a, b, sk, qk from gapinput
sequence q as (order by sk key qk every 1 between $1 and 8);
PREPARE
execute x(4);
 a  | b | sk | qk 
----+---+----+----
  0 | 0 |  1 |  1
  7 | 0 |  2 |  2
  1 | 0 |  3 |  3
  8 | 0 |  4 |  4
  2 | 0 |  5 |  5
  3 | 0 |  6 |  6
  9 | 0 |  7 |  7
    |   |    |  8
  4 | 0 |  9 |  9
 10 | 0 | 10 | 10
  5 | 0 | 11 | 11
 11 | 0 | 12 | 12
  6 | 0 | 13 | 13
 12 | 0 | 14 | 14
(14 rows)

deallocate x;
DEALLOCATE
prepare x (int, int) as
select a, b, sk, qk from gapinput
sequence q as (order by sk key qk every 1 between $1 and $2);
PREPARE
execute x(4, 8);
 a  | b | sk | qk 
----+---+----+----
  0 | 0 |  1 |  1
  7 | 0 |  2 |  2
  1 | 0 |  3 |  3
  8 | 0 |  4 |  4
  2 | 0 |  5 |  5
  3 | 0 |  6 |  6
  9 | 0 |  7 |  7
    |   |    |  8
  4 | 0 |  9 |  9
 10 | 0 | 10 | 10
  5 | 0 | 11 | 11
 11 | 0 | 12 | 12
  6 | 0 | 13 | 13
 12 | 0 | 14 | 14
(14 rows)

execute x(8, 4);
 a  | b | sk | qk 
----+---+----+----
  0 | 0 |  1 |  1
  7 | 0 |  2 |  2
  1 | 0 |  3 |  3
  8 | 0 |  4 |  4
  2 | 0 |  5 |  5
  3 | 0 |  6 |  6
  9 | 0 |  7 |  7
  4 | 0 |  9 |  9
 10 | 0 | 10 | 10
  5 | 0 | 11 | 11
 11 | 0 | 12 | 12
  6 | 0 | 13 | 13
 12 | 0 | 14 | 14
(13 rows)

deallocate x;
DEALLOCATE
-- on view
create view gapinputview as select pk1, pk2, a, b, sk from gapinput where a  < 5;
CREATE VIEW
select a, b, sk, qk from gapinputview
sequence q as (order by sk key qk every 1 between 4 and 8);
 a | b | sk | qk 
---+---+----+----
 0 | 0 |  1 |  1
 1 | 0 |  3 |  3
   |   |    |  4
 2 | 0 |  5 |  5
 3 | 0 |  6 |  6
   |   |    |  7
   |   |    |  8
 4 | 0 |  9 |  9
(8 rows)

-- null order by
select a, b, sk, qk
from(values(2, 20, null::int))as foo (a, b, sk)
sequence q as (order by sk key qk every 1 between 4 and 8);
psql:/path/sql_file:1: ERROR:  null value not allowed in sequence ordering key
HINT:  Consider using coalese to assign a non-null value to the key.
-- functions
CREATE OR REPLACE FUNCTION mygapfunc (evry int,s int, e int)
RETURNS SETOF record AS $$
  	select t1.sk, rank() over(q), qk
	from gapinput t1 inner join gapinput t2 on t1.a = t2.b
	sequence q as (order by t1.sk key qk every $1 between $2 and $3);
$$ LANGUAGE SQL;
CREATE FUNCTION
select mygapfunc(1,4,8);
 mygapfunc 
-----------
 (1,1,1)
 (1,2,1)
 (1,3,1)
 (1,4,1)
 (1,5,1)
 (1,6,1)
 (1,7,1)
 (1,8,1)
 (1,9,1)
 (1,10,1)
 (1,11,1)
 (1,12,1)
 (1,13,1)
 (,13,4)
 (,13,5)
 (,13,6)
 (,13,7)
 (,13,8)
(18 rows)

drop function mygapfunc(evry integer, s integer, e integer);
DROP FUNCTION
    
-- partition
create table gapinput_partition 
( like gapinput ) partition by range(a) ( start (0) end (20) every (2));
psql:/path/sql_file:1: NOTICE:  Table doesn't have 'distributed by' clause, defaulting to distribution columns from LIKE table
psql:/path/sql_file:1: NOTICE:  CREATE TABLE will create partition "gapinput_partition_1_prt_1" for table "gapinput_partition"
psql:/path/sql_file:1: NOTICE:  CREATE TABLE will create partition "gapinput_partition_1_prt_2" for table "gapinput_partition"
psql:/path/sql_file:1: NOTICE:  CREATE TABLE will create partition "gapinput_partition_1_prt_3" for table "gapinput_partition"
psql:/path/sql_file:1: NOTICE:  CREATE TABLE will create partition "gapinput_partition_1_prt_4" for table "gapinput_partition"
psql:/path/sql_file:1: NOTICE:  CREATE TABLE will create partition "gapinput_partition_1_prt_5" for table "gapinput_partition"
psql:/path/sql_file:1: NOTICE:  CREATE TABLE will create partition "gapinput_partition_1_prt_6" for table "gapinput_partition"
psql:/path/sql_file:1: NOTICE:  CREATE TABLE will create partition "gapinput_partition_1_prt_7" for table "gapinput_partition"
psql:/path/sql_file:1: NOTICE:  CREATE TABLE will create partition "gapinput_partition_1_prt_8" for table "gapinput_partition"
psql:/path/sql_file:1: NOTICE:  CREATE TABLE will create partition "gapinput_partition_1_prt_9" for table "gapinput_partition"
psql:/path/sql_file:1: NOTICE:  CREATE TABLE will create partition "gapinput_partition_1_prt_10" for table "gapinput_partition"
CREATE TABLE
insert into gapinput_partition select * from gapinput;
INSERT 0 13
select pk1, a, b, sk, qk lead(sk) over (q), lag(qk) over (q),
	first_value(sk) over(q), last_value(qk) over (q)
from gapinput_partition
sequence q as (partition by pk1 order by sk key qk every 3 between 2 and 6);
psql:/path/sql_file:1: ERROR:  syntax error at or near "("
LINE 1: select pk1, a, b, sk, qk lead(sk) over (q), lag(qk) over (q)...
                                     ^
drop table gapinput_partition;
DROP TABLE
-- index
set enable_seqscan=off;
SET
set enable_bitmapscan=off;
SET
set enable_indexscan=on;
SET
create index gapinput_index on gapinput (a);
CREATE INDEX
select t1.sk, rank() over(q), qk
from gapinput t1 inner join gapinput t2 on t1.a = t2.b
sequence q as (order by t1.sk key qk every 1 between 4 and 8);
 sk | rank | qk 
----+------+----
  1 |    1 |  1
  1 |    2 |  1
  1 |    3 |  1
  1 |    4 |  1
  1 |    5 |  1
  1 |    6 |  1
  1 |    7 |  1
  1 |    8 |  1
  1 |    9 |  1
  1 |   10 |  1
  1 |   11 |  1
  1 |   12 |  1
  1 |   13 |  1
    |   13 |  4
    |   13 |  5
    |   13 |  6
    |   13 |  7
    |   13 |  8
(18 rows)

drop index gapinput_index;
DROP INDEX
-- IGNORE NULLS for lead and lag
create table ignull(i numeric, j numeric, k numeric) distributed by(i);
psql:/path/sql_file:1: ERROR:  relation "ignull" already exists
copy ignull from stdin;
select i, j, lead(j) ignore nulls over (order by i) as f1,
	lead(j, 0) ignore nulls over (order by i) as f2,
	lead(j, 2) ignore nulls over (order by i) as f3,
	lead(j, 0, -1) ignore nulls over (order by i) as f4,
	lead(j, i::bigint) ignore nulls over (order by i) as f5
	from ignull;
 i  | j | f1 | f2 | f3 | f4 | f5 
----+---+----+----+----+----+----
  1 |   |  3 |  3 |  4 |  3 |  3
  1 |   |  3 |  3 |  4 |  3 |  3
  2 |   |  3 |  3 |  4 |  3 |  4
  2 |   |  3 |  3 |  4 |  3 |  4
  3 | 3 |  3 |  3 |  4 |  3 |  4
  3 | 3 |  4 |  3 |  4 |  3 |  6
  4 | 4 |  4 |  4 |  6 |  4 |  7
  4 | 4 |  6 |  4 |  6 |  4 |  7
  5 |   |  6 |  6 |  7 |  6 |   
  5 |   |  6 |  6 |  7 |  6 |   
  6 | 6 |  6 |  6 |  7 |  6 |   
  6 | 6 |  7 |  6 |  7 |  6 |   
  7 | 7 |  7 |  7 |    |  7 |   
  7 | 7 |    |  7 |    |  7 |   
  8 |   |    |    |    | -1 |   
  8 |   |    |    |    | -1 |   
  9 |   |    |    |    | -1 |   
  9 |   |    |    |    | -1 |   
 10 |   |    |    |    | -1 |   
 10 |   |    |    |    | -1 |   
(20 rows)

select i, j, lag(j) ignore nulls over (order by i) as l1,
	lag(j, 0) ignore nulls over (order by i) as l2,
	lag(j, 2) ignore nulls over (order by i) as l3,
	lag(j, 0, -1) ignore nulls over (order by i) as l4,
	lag(j, 10-i::bigint) ignore nulls over (order by i) as l5
	from ignull;
 i  | j | l1 | l2 | l3 | l4 | l5 
----+---+----+----+----+----+----
  1 |   |    |    |    | -1 |   
  1 |   |    |    |    | -1 |   
  2 |   |    |    |    | -1 |   
  2 |   |    |    |    | -1 |   
  3 | 3 |    |  3 |    |  3 |   
  3 | 3 |  3 |  3 |    |  3 |   
  4 | 4 |  3 |  4 |  3 |  4 |   
  4 | 4 |  4 |  4 |  3 |  4 |   
  5 |   |  4 |  4 |  3 |  4 |   
  5 |   |  4 |  4 |  3 |  4 |   
  6 | 6 |  4 |  6 |  4 |  6 |  3
  6 | 6 |  6 |  6 |  4 |  6 |  3
  7 | 7 |  6 |  7 |  6 |  7 |  4
  7 | 7 |  7 |  7 |  6 |  7 |  6
  8 |   |  7 |  7 |  6 |  7 |  6
  8 |   |  7 |  7 |  6 |  7 |  6
  9 |   |  7 |  7 |  6 |  7 |  7
  9 |   |  7 |  7 |  6 |  7 |  7
 10 |   |  7 |  7 |  6 |  7 |  7
 10 |   |  7 |  7 |  6 |  7 |  7
(20 rows)

select k, i, j, lead(j) ignore nulls over (partition by k order by i) as f10,
	lag(j) ignore nulls over (partition by k order by i) as l10
	from ignull order by k, i;
 k | i  | j | f10 | l10 
---+----+---+-----+-----
 1 |  1 |   |   3 |    
 1 |  1 |   |   3 |    
 1 |  2 |   |   3 |    
 1 |  2 |   |   3 |    
 1 |  3 | 3 |   4 |   3
 1 |  3 | 3 |   3 |    
 1 |  4 | 4 |     |   4
 1 |  4 | 4 |   4 |   3
 2 |  5 |   |   6 |    
 2 |  5 |   |   6 |    
 2 |  6 | 6 |   7 |   6
 2 |  6 | 6 |   6 |    
 2 |  7 | 7 |     |   7
 2 |  7 | 7 |   7 |   6
 2 |  8 |   |     |   7
 2 |  8 |   |     |   7
 2 |  9 |   |     |   7
 2 |  9 |   |     |   7
 3 | 10 |   |     |    
 3 | 10 |   |     |    
(20 rows)

